import macro from '../../macro.js';
import vtkViewNode from '../SceneGraph/ViewNode.js';
import { registerOverride } from './ViewNodeFactory.js';
import { j as transpose, t as translate } from '../../vendor/gl-matrix/esm/mat4.js';

// vtkWebGPUVolume methods
// ----------------------------------------------------------------------------

function vtkWebGPUVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUVolume'); // Builds myself.

  publicAPI.buildPass = function (prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }

    if (prepass) {
      model.WebGPURenderer = publicAPI.getFirstAncestorOfType('vtkWebGPURenderer');
      model.WebGPURenderWindow = model.WebGPURenderer.getFirstAncestorOfType('vtkWebGPURenderWindow'); // for the future if we support hardware selection of volumes

      if (model.propID === undefined) {
        model.propID = model.WebGPURenderWindow.getUniquePropID();
      }

      publicAPI.prepareNodes();
      model.renderable.getMapper().update(); // publicAPI.addMissingNode(model.renderable.getMapper());

      publicAPI.removeUnusedNodes();
    }
  };

  publicAPI.queryPass = function (prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      } // Check for the special case when the mapper's bounds are unknown


      var bds = model.renderable.getMapper().getBounds();

      if (!bds || bds.length !== 6 || bds[0] > bds[1]) {
        return;
      }

      renderPass.addVolume(publicAPI);
    }
  };

  publicAPI.getBoundingCubePoints = function (result, offset) {
    var bounds = model.renderable.getMapper().getBounds();
    var m = model.renderable.getMatrix();
    var count = 0;

    for (var iz = 4; iz < 6; iz++) {
      var z = bounds[iz];

      for (var iy = 2; iy < 4; iy++) {
        var y = bounds[iy];

        for (var ix = 0; ix < 2; ix++) {
          var x = bounds[ix];
          var poffset = offset + count * 3;
          result[poffset++] = m[0] * x + m[1] * y + m[2] * z + m[3];
          result[poffset++] = m[4] * x + m[5] * y + m[6] * z + m[7];
          result[poffset++] = m[8] * x + m[9] * y + m[10] * z + m[11];
          count++;
        }
      }
    }
  };

  publicAPI.traverseVolumePass = function (renderPass) {
    if (!model.renderable || !model.renderable.getVisibility() || model.WebGPURenderer.getSelector() && !model.renderable.getPickable()) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  };

  publicAPI.getKeyMatrices = function (wgpuRen) {
    // has the actor or stabilization center changed?
    if (Math.max(model.renderable.getMTime(), wgpuRen.getStabilizedTime()) > model.keyMatricesTime.getMTime()) {
      model.renderable.computeMatrix();
      var mcwc = model.renderable.getMatrix(); // compute the net shift

      var center = wgpuRen.getStabilizedCenterByReference();
      transpose(model.keyMatrices.bcwc, mcwc); // to get to stabilized we also need the center

      translate(model.keyMatrices.bcsc, model.keyMatrices.bcwc, [-center[0], -center[1], -center[2]]);
      model.keyMatricesTime.modified();
    }

    return model.keyMatrices;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  propID: undefined,
  keyMatricesTime: null
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkViewNode.extend(publicAPI, model, initialValues);
  model.keyMatricesTime = {};
  macro.obj(model.keyMatricesTime, {
    mtime: 0
  });
  model.keyMatrices = {
    bcwc: new Float64Array(16),
    bcsc: new Float64Array(16)
  };
  macro.get(publicAPI, model, ['propID', 'keyMatricesTime']); // Object methods

  vtkWebGPUVolume(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkWebGPUVolume'); // ----------------------------------------------------------------------------

var index = {
  newInstance: newInstance,
  extend: extend
}; // Register ourself to WebGPU backend if imported

registerOverride('vtkVolume', newInstance);

export default index;
export { extend, newInstance };
