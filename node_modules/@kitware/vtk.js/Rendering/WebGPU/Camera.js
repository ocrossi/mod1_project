import macro from '../../macro.js';
import vtkViewNode from '../SceneGraph/ViewNode.js';
import { registerOverride } from './ViewNodeFactory.js';
import { d as copy, g as invert, j as transpose, t as translate, m as multiply } from '../../vendor/gl-matrix/esm/mat4.js';

// vtkWebGPUCamera methods
// ----------------------------------------------------------------------------

function vtkWebGPUCamera(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkWebGPUCamera');

  publicAPI.getKeyMatrices = function (webGPURenderer) {
    // has the camera changed?
    var ren = webGPURenderer.getRenderable();
    var webGPURenderWindow = webGPURenderer.getParent();

    if (Math.max(webGPURenderWindow.getMTime(), publicAPI.getMTime(), ren.getMTime(), model.renderable.getMTime(), webGPURenderer.getStabilizedTime()) > model.keyMatrixTime.getMTime()) {
      var wcvc = model.renderable.getViewMatrix();
      copy(model.keyMatrices.normalMatrix, wcvc); // zero out translation

      model.keyMatrices.normalMatrix[3] = 0.0;
      model.keyMatrices.normalMatrix[7] = 0.0;
      model.keyMatrices.normalMatrix[11] = 0.0;
      invert(model.keyMatrices.normalMatrix, model.keyMatrices.normalMatrix);
      transpose(model.keyMatrices.wcvc, wcvc);
      var center = webGPURenderer.getStabilizedCenterByReference();
      translate(model.keyMatrices.scvc, model.keyMatrices.wcvc, center);
      var aspectRatio = webGPURenderer.getAspectRatio();
      var vcpc = model.renderable.getProjectionMatrix(aspectRatio, -1, 1);
      transpose(model.keyMatrices.vcpc, vcpc); // adjust due to WebGPU using a different coordinate system in Z

      model.keyMatrices.vcpc[2] = 0.5 * vcpc[8] + 0.5 * vcpc[12];
      model.keyMatrices.vcpc[6] = 0.5 * vcpc[9] + 0.5 * vcpc[13];
      model.keyMatrices.vcpc[10] = 0.5 * vcpc[10] + 0.5 * vcpc[14];
      model.keyMatrices.vcpc[14] = 0.5 * vcpc[11] + 0.5 * vcpc[15];
      multiply(model.keyMatrices.scpc, model.keyMatrices.vcpc, model.keyMatrices.scvc);
      invert(model.keyMatrices.pcsc, model.keyMatrices.scpc);
      model.keyMatrixTime.modified();
    }

    return model.keyMatrices;
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  keyMatrixTime: null,
  keyMatrices: null
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkViewNode.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  macro.obj(model.keyMatrixTime); // values always get set by the get method

  model.keyMatrices = {
    normalMatrix: new Float64Array(16),
    vcpc: new Float64Array(16),
    pcsc: new Float64Array(16),
    wcvc: new Float64Array(16),
    scpc: new Float64Array(16),
    scvc: new Float64Array(16)
  }; // Build VTK API

  macro.setGet(publicAPI, model, ['keyMatrixTime']); // Object methods

  vtkWebGPUCamera(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend); // ----------------------------------------------------------------------------

var index = {
  newInstance: newInstance,
  extend: extend
}; // Register ourself to WebGPU backend if imported

registerOverride('vtkCamera', newInstance);

export default index;
export { extend, newInstance };
