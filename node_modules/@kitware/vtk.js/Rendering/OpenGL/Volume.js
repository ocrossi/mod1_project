import { obj, setGet, newInstance as newInstance$1 } from '../../macro.js';
import vtkViewNode from '../SceneGraph/ViewNode.js';
import { registerOverride } from './ViewNodeFactory.js';
import { d as copy, j as transpose } from '../../vendor/gl-matrix/esm/mat4.js';
import { i as identity, f as fromMat4, a as invert } from '../../vendor/gl-matrix/esm/mat3.js';

// vtkOpenGLVolume methods
// ----------------------------------------------------------------------------

function vtkOpenGLVolume(publicAPI, model) {
  // Set our className
  model.classHierarchy.push('vtkOpenGLVolume'); // Builds myself.

  publicAPI.buildPass = function (prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }

    if (prepass) {
      model.openGLRenderer = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderer');
      publicAPI.prepareNodes();
      publicAPI.addMissingNode(model.renderable.getMapper());
      publicAPI.removeUnusedNodes();
    }
  };

  publicAPI.queryPass = function (prepass, renderPass) {
    if (prepass) {
      if (!model.renderable || !model.renderable.getVisibility()) {
        return;
      }

      renderPass.incrementVolumeCount();
    }
  };

  publicAPI.traverseVolumePass = function (renderPass) {
    if (!model.renderable || !model.renderable.getVisibility() || model.openGLRenderer.getSelector() && !model.renderable.getPickable()) {
      return;
    }

    publicAPI.apply(renderPass, true);
    model.children[0].traverse(renderPass);
    publicAPI.apply(renderPass, false);
  }; // Renders myself


  publicAPI.volumePass = function (prepass) {
    if (!model.renderable || !model.renderable.getVisibility()) {
      return;
    }

    if (prepass) {
      model.context = publicAPI.getFirstAncestorOfType('vtkOpenGLRenderWindow').getContext();
      model.context.depthMask(false);
    } else {
      model.context.depthMask(true);
    }
  };

  publicAPI.getKeyMatrices = function () {
    // has the actor changed?
    if (model.renderable.getMTime() > model.keyMatrixTime.getMTime()) {
      model.renderable.computeMatrix();
      copy(model.MCWCMatrix, model.renderable.getMatrix());
      transpose(model.MCWCMatrix, model.MCWCMatrix);

      if (model.renderable.getIsIdentity()) {
        identity(model.normalMatrix);
      } else {
        fromMat4(model.normalMatrix, model.MCWCMatrix);
        invert(model.normalMatrix, model.normalMatrix);
      }

      model.keyMatrixTime.modified();
    }

    return {
      mcwc: model.MCWCMatrix,
      normalMatrix: model.normalMatrix
    };
  };
} // ----------------------------------------------------------------------------
// Object factory
// ----------------------------------------------------------------------------


var DEFAULT_VALUES = {// context: null,
  // keyMatrixTime: null,
  // normalMatrix: null,
  // MCWCMatrix: null,
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues); // Inheritance

  vtkViewNode.extend(publicAPI, model, initialValues);
  model.keyMatrixTime = {};
  obj(model.keyMatrixTime, {
    mtime: 0
  }); // always set by getter

  model.normalMatrix = new Float64Array(9);
  model.MCWCMatrix = new Float64Array(16); // Build VTK API

  setGet(publicAPI, model, ['context']); // Object methods

  vtkOpenGLVolume(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = newInstance$1(extend, 'vtkOpenGLVolume'); // ----------------------------------------------------------------------------

var vtkVolume = {
  newInstance: newInstance,
  extend: extend
}; // Register ourself to OpenGL backend if imported

registerOverride('vtkVolume', newInstance);

export default vtkVolume;
export { extend, newInstance };
