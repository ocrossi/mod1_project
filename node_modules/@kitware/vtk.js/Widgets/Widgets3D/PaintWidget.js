import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import macro from '../../macro.js';
import vtkAbstractWidgetFactory from '../Core/AbstractWidgetFactory.js';
import vtkCircleContextRepresentation from '../Representations/CircleContextRepresentation.js';
import vtkPlanePointManipulator from '../Manipulators/PlaneManipulator.js';
import vtkSphereHandleRepresentation from '../Representations/SphereHandleRepresentation.js';
import vtkStateBuilder from '../Core/StateBuilder.js';
import { ViewTypes } from '../Core/WidgetManager/Constants.js';
import { c as cross } from '../../vendor/gl-matrix/esm/vec3.js';

// Widget linked to a view
// ----------------------------------------------------------------------------

function widgetBehavior(publicAPI, model) {
  publicAPI.handleLeftButtonPress = function (callData) {
    if (!model.activeState || !model.activeState.getActive()) {
      return macro.VOID;
    }

    model.painting = true;
    var trailCircle = model.widgetState.addTrail();
    trailCircle.set(model.activeState.get('origin', 'up', 'right', 'direction', 'scale1'));
    publicAPI.invokeStartInteractionEvent();
    return macro.EVENT_ABORT;
  };

  publicAPI.handleMouseMove = function (callData) {
    return publicAPI.handleEvent(callData);
  };

  publicAPI.handleLeftButtonRelease = function () {
    if (model.painting) {
      publicAPI.invokeEndInteractionEvent();
      model.widgetState.clearTrailList();
    }

    model.painting = false;
  };

  publicAPI.handleEvent = function (callData) {
    if (model.manipulator && model.activeState && model.activeState.getActive()) {
      var _model$activeState, _model$activeState2, _model$activeState3;

      var normal = model.camera.getDirectionOfProjection();
      var up = model.camera.getViewUp();
      var right = [];
      cross(right, up, normal);

      (_model$activeState = model.activeState).setUp.apply(_model$activeState, _toConsumableArray(up));

      (_model$activeState2 = model.activeState).setRight.apply(_model$activeState2, right);

      (_model$activeState3 = model.activeState).setDirection.apply(_model$activeState3, _toConsumableArray(normal));

      model.manipulator.setNormal(normal);
      var worldCoords = model.manipulator.handleEvent(callData, model.apiSpecificRenderWindow);

      if (worldCoords.length) {
        var _model$widgetState, _model$activeState4;

        (_model$widgetState = model.widgetState).setTrueOrigin.apply(_model$widgetState, _toConsumableArray(worldCoords));

        (_model$activeState4 = model.activeState).setOrigin.apply(_model$activeState4, _toConsumableArray(worldCoords));

        if (model.painting) {
          var trailCircle = model.widgetState.addTrail();
          trailCircle.set(model.activeState.get('origin', 'up', 'right', 'direction', 'scale1'));
        }
      }

      publicAPI.invokeInteractionEvent();
      return macro.EVENT_ABORT;
    }

    return macro.VOID;
  };

  publicAPI.grabFocus = function () {
    if (!model.hasFocus) {
      model.activeState = model.widgetState.getHandle();
      model.activeState.activate();
      model.interactor.requestAnimation(publicAPI);
      var canvas = model.apiSpecificRenderWindow.getCanvas();

      canvas.onmouseenter = function () {
        if (model.hasFocus && model.activeState === model.widgetState.getHandle()) {
          model.activeState.setVisible(true);
        }
      };

      canvas.onmouseleave = function () {
        if (model.hasFocus && model.activeState === model.widgetState.getHandle()) {
          model.activeState.setVisible(false);
        }
      };
    }

    model.hasFocus = true;
  };

  publicAPI.loseFocus = function () {
    if (model.hasFocus) {
      model.interactor.cancelAnimation(publicAPI);
    }

    model.widgetState.deactivate();
    model.widgetState.getHandle().deactivate();
    model.activeState = null;
    model.hasFocus = false;
  };

  macro.get(publicAPI, model, ['painting']);
} // ----------------------------------------------------------------------------
// Factory
// ----------------------------------------------------------------------------


function vtkPaintWidget(publicAPI, model) {
  model.classHierarchy.push('vtkPaintWidget'); // --- Widget Requirement ---------------------------------------------------

  model.behavior = widgetBehavior;

  publicAPI.getRepresentationsForViewType = function (viewType) {
    switch (viewType) {
      case ViewTypes.DEFAULT:
      case ViewTypes.GEOMETRY:
      case ViewTypes.SLICE:
        return [{
          builder: vtkCircleContextRepresentation,
          labels: ['handle', 'trail']
        }];

      case ViewTypes.VOLUME:
      default:
        return [{
          builder: vtkSphereHandleRepresentation,
          labels: ['handle']
        }];
    }
  }; // --- Widget Requirement ---------------------------------------------------
  // Default state


  model.widgetState = vtkStateBuilder.createBuilder().addField({
    name: 'trueOrigin',
    initialValue: [0, 0, 0]
  }).addStateFromMixin({
    labels: ['handle'],
    mixins: ['origin', 'color', 'scale1', 'orientation', 'manipulator', 'visible'],
    name: 'handle',
    initialValues: {
      scale1: model.radius * 2,
      origin: [0, 0, 0],
      orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1],
      visible: true
    }
  }).addDynamicMixinState({
    labels: ['trail'],
    mixins: ['origin', 'color', 'scale1', 'orientation'],
    name: 'trail',
    initialValues: {
      scale1: model.radius * 2,
      origin: [0, 0, 0],
      orientation: [1, 0, 0, 0, 1, 0, 0, 0, 1]
    }
  }).build();
  var handle = model.widgetState.getHandle(); // Default manipulator

  model.manipulator = vtkPlanePointManipulator.newInstance();
  handle.setManipulator(model.manipulator); // override

  var superSetRadius = publicAPI.setRadius;

  publicAPI.setRadius = function (r) {
    if (superSetRadius(r)) {
      handle.setScale1(r);
    }
  };
} // ----------------------------------------------------------------------------


var DEFAULT_VALUES = {
  manipulator: null,
  radius: 1,
  painting: false,
  color: [1]
}; // ----------------------------------------------------------------------------

function extend(publicAPI, model) {
  var initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  Object.assign(model, DEFAULT_VALUES, initialValues);
  vtkAbstractWidgetFactory.extend(publicAPI, model, initialValues);
  macro.get(publicAPI, model, ['painting']);
  macro.setGet(publicAPI, model, ['manipulator', 'radius', 'color']);
  vtkPaintWidget(publicAPI, model);
} // ----------------------------------------------------------------------------

var newInstance = macro.newInstance(extend, 'vtkPaintWidget'); // ----------------------------------------------------------------------------

var vtkPaintWidget$1 = {
  newInstance: newInstance,
  extend: extend
};

export default vtkPaintWidget$1;
export { extend, newInstance };
