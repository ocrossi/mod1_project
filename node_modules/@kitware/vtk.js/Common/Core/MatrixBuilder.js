import _toConsumableArray from '@babel/runtime/helpers/toConsumableArray';
import _classCallCheck from '@babel/runtime/helpers/classCallCheck';
import _createClass from '@babel/runtime/helpers/createClass';
import { t as toRadian } from '../../vendor/gl-matrix/esm/common.js';
import { i as identity, f as fromRotation, m as multiply, r as rotate, a as rotateX, b as rotateY, c as rotateZ, t as translate, s as scale, d as copy } from '../../vendor/gl-matrix/esm/mat4.js';
import { s as set, n as normalize, d as dot, c as cross, l as length, v as vec3, t as transformMat4 } from '../../vendor/gl-matrix/esm/vec3.js';
import { a as areMatricesEqual } from './Math/index.js';

var NoOp = function NoOp(v) {
  return v;
};

var IDENTITY = identity(new Float64Array(16));
var EPSILON = 1e-6;

var Transform = /*#__PURE__*/function () {
  function Transform() {
    var useDegree = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

    _classCallCheck(this, Transform);

    this.matrix = identity(new Float64Array(16));
    this.tmp = new Float64Array(3);
    this.angleConv = useDegree ? toRadian : NoOp;
  }

  _createClass(Transform, [{
    key: "rotateFromDirections",
    value: function rotateFromDirections(originDirection, targetDirection) {
      var src = new Float64Array(3);
      var dst = new Float64Array(3);
      var transf = new Float64Array(16);
      set(src, originDirection[0], originDirection[1], originDirection[2]);
      set(dst, targetDirection[0], targetDirection[1], targetDirection[2]);
      normalize(src, src);
      normalize(dst, dst);
      var cosAlpha = dot(src, dst);

      if (cosAlpha >= 1) {
        return this;
      }

      cross(this.tmp, src, dst);

      if (length(this.tmp) < EPSILON) {
        // cross product is 0, so pick arbitrary axis perpendicular
        // to originDirection.
        cross(this.tmp, [1, 0, 0], originDirection);

        if (length(this.tmp) < EPSILON) {
          cross(this.tmp, [0, 1, 0], originDirection);
        }
      }

      fromRotation(transf, Math.acos(cosAlpha), this.tmp);
      multiply(this.matrix, this.matrix, transf);
      return this;
    }
  }, {
    key: "rotate",
    value: function rotate$1(angle, axis) {
      set.apply(vec3, [this.tmp].concat(_toConsumableArray(axis)));
      normalize(this.tmp, this.tmp);
      rotate(this.matrix, this.matrix, this.angleConv(angle), this.tmp);
      return this;
    }
  }, {
    key: "rotateX",
    value: function rotateX$1(angle) {
      rotateX(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "rotateY",
    value: function rotateY$1(angle) {
      rotateY(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "rotateZ",
    value: function rotateZ$1(angle) {
      rotateZ(this.matrix, this.matrix, this.angleConv(angle));
      return this;
    }
  }, {
    key: "translate",
    value: function translate$1(x, y, z) {
      set(this.tmp, x, y, z);
      translate(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "scale",
    value: function scale$1(sx, sy, sz) {
      set(this.tmp, sx, sy, sz);
      scale(this.matrix, this.matrix, this.tmp);
      return this;
    }
  }, {
    key: "multiply",
    value: function multiply$1(mat4x4) {
      multiply(this.matrix, this.matrix, mat4x4);
      return this;
    }
  }, {
    key: "identity",
    value: function identity$1() {
      identity(this.matrix);
      return this;
    } //-----------

  }, {
    key: "apply",
    value: function apply(typedArray) {
      var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
      var nbIterations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : -1;

      if (areMatricesEqual(IDENTITY, this.matrix)) {
        // Make sure we can chain apply...
        return this;
      }

      var size = nbIterations === -1 ? typedArray.length : offset + nbIterations * 3;

      for (var i = offset; i < size; i += 3) {
        set(this.tmp, typedArray[i], typedArray[i + 1], typedArray[i + 2]);
        transformMat4(this.tmp, this.tmp, this.matrix);
        typedArray[i] = this.tmp[0];
        typedArray[i + 1] = this.tmp[1];
        typedArray[i + 2] = this.tmp[2];
      } // Make sure we can chain apply...


      return this;
    }
  }, {
    key: "getMatrix",
    value: function getMatrix() {
      return this.matrix;
    }
  }, {
    key: "setMatrix",
    value: function setMatrix(mat4x4) {
      if (!!mat4x4 && mat4x4.length === 16) {
        copy(this.matrix, mat4x4);
      }

      return this;
    }
  }]);

  return Transform;
}();

function buildFromDegree() {
  return new Transform(true);
}

function buildFromRadian() {
  return new Transform(false);
}

var vtkMatrixBuilder = {
  buildFromDegree: buildFromDegree,
  buildFromRadian: buildFromRadian
};

export default vtkMatrixBuilder;
